(function(window) {
	var HAS_HASHCHANGE = (function() {
		var doc_mode = window.documentMode;
		return ('onhashchange' in window) &&
			(doc_mode === undefined || doc_mode > 7);
	})();

	L.Hash = function(map) {
		this.onHashChange = L.Util.bind(this.onHashChange, this);

		if (map) {
			this.init(map);
		}
	};

	L.Hash.parseHash = function(hash) {
		if(hash.indexOf('#') === 0) {
			hash = hash.substr(1);
		}
		var args = hash.split("/");
		if (args.length) {
			var zoom = parseInt(args[0], 10),
			lat = parseFloat(args[1]),
			lon = parseFloat(args[2]);
			var layers = [];
			if (args[3]) {
			    layers = args[3].split(',');                
            }
			if (isNaN(zoom) || isNaN(lat) || isNaN(lon)) {
				return false;
			} else {
				return {
					center: new L.LatLng(lat, lon),
					zoom: zoom,
                    layers: layers
				};
			}
		} else {
			return false;
		}
	};

	L.Hash.formatHash = function(map) {
	    var center = map.getCenter(),
		    zoom = map.getZoom(),
		    precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),
            layerHash = '';

	    var allLayers = map._HatTOC._allLayers._layers;
	    var layerList = [];

	    for (layer in allLayers) {
	        layerList.push(allLayers[layer]);
	    }

	    var layerHash = layerList.filter(function (layer) {
	        return (map.hasLayer(layer));
	    }).map(function (layer) {
	        return layer.hashName;
	    }).join(',');

	    return "#" + [zoom,
			center.lat.toFixed(precision),
			center.lng.toFixed(precision),
            layerHash
		].join("/");
	},

	L.Hash.prototype = {
		map: null,
		lastHash: null,

		parseHash: L.Hash.parseHash,
		formatHash: L.Hash.formatHash,

		init: function(map) {
		    this.map = map;

            /*
		    var redlinerNetworkProxy = $.connection.redlinerNetwork;
		    redlinerNetworkProxy.client.otherUserHashChanged = function (otherUserHash) {		        
		        console.log('Another clients hash has changed to ' + otherUserHash);
                // disabled
		        // location.replace(otherUserHash);
		    }
            */
			// reset the hash
			this.lastHash = null;

			if (location.hash.length != 0) {
			    var layers = location.hash.split('/').pop().split(',');
			    var checkLayers = function () {
                    //uncheck all
			        $('.aciTree').aciTree('api').uncheck($('.aciTreeCheckbox'));
			        //tick on individuals
			        layers.forEach(function (layer) {
			            $('.aciTree').aciTree('api').check($('.aciTreeCheckbox').eq(parseInt(layer)));
			        });
			        map.off('tree-data-loaded', checkLayers); //turn self off
			    }
			    //map.on('tree-data-loaded', checkLayers);
			} else {
			    var hash = this.formatHash(this.map);
			    if (this.lastHash != hash) {
			        location.replace(hash);
			        this.lastHash = hash;
			    }
			}

			if (!this.isListening) {
				this.startListening();
			}
		},

		removeFrom: function(map) {
			if (this.changeTimeout) {
				clearTimeout(this.changeTimeout);
			}

			if (this.isListening) {
				this.stopListening();
			}

			this.map = null;
		},

		onMapMove: function () {
			// bail if we're moving the map (updating from a hash),
			// or if the map is not yet loaded
			if (this.movingMap || !this.map._loaded) {
				return false;
			}

			var hash = this.formatHash(this.map);
			if (this.lastHash != hash) {
			    location.replace(hash);
			    this.sendHashChangedEventToServer();
				this.lastHash = hash;
			}
		},

		sendHashChangedEventToServer: function () {
            /*
		    $.connection.hub.start().done(function () {
		        var redlinerNetworkProxy = $.connection.redlinerNetwork;
		        redlinerNetworkProxy.server.hashChanged(location.hash, location.toString());
		    });
            */
		    
		},

		setLayersChecked: function(parsedHash) {
		    
		    if (this.map._HatTOC && this.map._HatTOC.setLayersCheckedByLayerIds) {
                // disabled
		        // this.map._HatTOC.setLayersCheckedByLayerIds(parsedHash.layers);
		    }
		    
		},

		movingMap: false,
		update: function() {
			var hash = location.hash;
			if (hash === this.lastHash) {
				return;
			}
			var parsed = this.parseHash(hash);
			if (parsed) {
				this.movingMap = true;
				this.sendHashChangedEventToServer();
				this.map.setView(parsed.center, parsed.zoom);
				this.setLayersChecked(parsed);
				this.movingMap = false;
			} else {
				this.onMapMove(this.map);
			}
		},

		// defer hash change updates every 100ms
		changeDefer: 100,
		changeTimeout: null,
		onHashChange: function() {
			// throttle calls to update() so that they only happen every
			// `changeDefer` ms
			if (!this.changeTimeout) {
				var that = this;
				this.changeTimeout = setTimeout(function() {
					that.update();
					that.changeTimeout = null;
				}, this.changeDefer);
			}
		},

		isListening: false,
		hashChangeInterval: null,
		startListening: function() {
		    this.map.on("moveend", this.onMapMove, this);
		    this.map.on('update-layer-hash', this.onMapMove, this);

			if (HAS_HASHCHANGE) {
				L.DomEvent.addListener(window, "hashchange", this.onHashChange);
			} else {
				clearInterval(this.hashChangeInterval);
				this.hashChangeInterval = setInterval(this.onHashChange, 50);
			}
			this.isListening = true;
		},

		stopListening: function() {
			this.map.off("moveend", this.onMapMove, this);

			if (HAS_HASHCHANGE) {
				L.DomEvent.removeListener(window, "hashchange", this.onHashChange);
			} else {
				clearInterval(this.hashChangeInterval);
			}
			this.isListening = false;
		}
	};
	L.hash = function(map) {
		return new L.Hash(map);
	};
	L.Map.prototype.addHash = function() {
		this._hash = L.hash(this);
	};
	L.Map.prototype.removeHash = function() {
		this._hash.removeFrom();
	};
})(window);
