using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;

namespace Hatfield.WebMap.Domain
{
    public enum TokenMode { ServerToServer, ClientToServer };
    
    public class TokenAuthService
    {
        // private static readonly ILog log = LogManager.GetLogger("Application");

        public static class EncodingHelper
        {
            private static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

            /// <summary>
            /// Converts a hex-encoded string to the corresponding byte array.
            /// </summary>
            /// <param name="hex">Hex-encoded string</param>
            /// <returns>Byte representation of the hex-encoded input</returns>
            public static byte[] HexToBytes(string hex)
            {
                int length = hex.Length;

                if (length % 2 != 0)
                {
                    length += 1;
                    hex = "0" + hex;
                }

                byte[] bytes = new byte[length / 2];
                for (int i = 0; i < length; i += 2)
                {
                    bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
                }

                return bytes;
            }

            /// <summary>
            /// Hex-encodes a byte array.
            /// </summary>
            /// <param name="bytes">Byte array to encode</param>
            /// <returns>Hex-encoded string</returns>
            public static string BytesToHex(byte[] bytes)
            {
                System.Text.StringBuilder sb = new System.Text.StringBuilder(bytes.Length * 2);

                for (int i = 0; i < bytes.Length; i++)
                {
                    sb.AppendFormat("{0:x2}", bytes[i]);
                }

                return sb.ToString();
            }

            /// <summary>
            /// Return the given DateTime as the count of milliseconds since the Unix epoch (1970-01-01).
            /// </summary>
            /// <param name="dateTime"></param>
            /// <returns></returns>
            public static long GetUnixTimestampMillis(DateTime dateTime)
            {
                dateTime = dateTime.ToUniversalTime();
                double totalMs = (dateTime - UnixEpoch).TotalMilliseconds;
                return (long)totalMs;
            }

            /// <summary>
            /// Return the current UTC date and time as the count of milliseconds since the Unix epoch (1970-01-01).
            /// </summary>
            /// <returns></returns>
            public static long GetCurrentUnixTimestampMillis()
            {
                return (long)(DateTime.UtcNow - UnixEpoch).TotalMilliseconds;
            }

            /// <summary>
            /// Return a DateTime corresponding to the input Unix timestamp (in milliseconds).
            /// </summary>
            /// <param name="millis"></param>
            /// <returns></returns>
            public static DateTime DateTimeFromUnixTimestampMillis(long millis)
            {
                return UnixEpoch.AddMilliseconds(millis);
            }
        }

        public Tuple<string, DateTime> getLayerAuthToken(TokenMode mode)
        {
            string Username = "webadmin";
            string Password = "m4x$p1A";
            int? desiredExpiration_minutes = 60 * 12; // 12 hours. Note: must be less than the server configured Long token period.

            Uri ServerUrl = new Uri("https://maps.hatfieldgroup.com/maps/tokens/");
            Uri encryptionInfoEndpoint = new Uri(ServerUrl, "publicKey?f=json");

            var eis = new System.Net.WebClient().DownloadString(encryptionInfoEndpoint);
            var ei = (Newtonsoft.Json.JsonConvert.DeserializeObject(eis) as Newtonsoft.Json.Linq.JObject);

            byte[] exponent = EncodingHelper.HexToBytes(ei.Value<string>("publicKey"));
            byte[] modulus = EncodingHelper.HexToBytes(ei.Value<string>("modulus"));

            string encryptedUsername, encryptedPassword, encryptedClient, encryptedExpiration = null;
            string encryptedHttpReferer = null;

            using (var rsa = new System.Security.Cryptography.RSACryptoServiceProvider(512))
            {
                var rsaParms = new System.Security.Cryptography.RSAParameters() { Exponent = exponent, Modulus = modulus };
                rsa.ImportParameters(rsaParms);

                encryptedUsername = EncodingHelper.BytesToHex(rsa.Encrypt(System.Text.Encoding.UTF8.GetBytes(Username), false));
                encryptedPassword = EncodingHelper.BytesToHex(rsa.Encrypt(System.Text.Encoding.UTF8.GetBytes(Password), false));
                if (mode ==TokenMode.ServerToServer)
                {
                    encryptedClient = EncodingHelper.BytesToHex(rsa.Encrypt(System.Text.Encoding.UTF8.GetBytes("requestip"), false));
                }
                else if (mode == TokenMode.ClientToServer)
                {
                    encryptedClient = EncodingHelper.BytesToHex(rsa.Encrypt(System.Text.Encoding.UTF8.GetBytes("referer"), false));

                    // log.Info("The referer is " + HttpContext.Current.Request.Url.Authority);
                    encryptedHttpReferer = EncodingHelper.BytesToHex(rsa.Encrypt(System.Text.Encoding.UTF8.GetBytes(HttpContext.Current.Request.Url.Authority), false));
                }
                else
                {
                    throw new Exception("Invalid token mode!");
                }

                if (desiredExpiration_minutes != null) encryptedExpiration = EncodingHelper.BytesToHex(rsa.Encrypt(System.Text.Encoding.UTF8.GetBytes(desiredExpiration_minutes.Value.ToString()), false));
            }

            Uri tokenEndpoint = new Uri(ServerUrl, "generateToken?f=json");

            var data = new System.Collections.Specialized.NameValueCollection();

            data.Add("username", encryptedUsername);
            data.Add("password", encryptedPassword);
            data.Add("client", encryptedClient);
            if (!string.IsNullOrEmpty(encryptedHttpReferer))
                data.Add("referer", encryptedHttpReferer);

            if (encryptedExpiration != null) data.Add("expiration", encryptedExpiration);
            data.Add("encrypted", "true");


            System.Net.WebClient postClient = new System.Net.WebClient();
            var tokenBytes = postClient.UploadValues(tokenEndpoint, data);
            var tokenString = System.Text.Encoding.UTF8.GetString(tokenBytes);
            // var tokenInfo = await PostAsync(tokenEndpoint, content, addToken: false);
            var tokenInfo = (Newtonsoft.Json.JsonConvert.DeserializeObject(tokenString) as Newtonsoft.Json.Linq.JObject);
            string Token = tokenInfo.Value<string>("token");

            var expirationUnixTimestamp = Convert.ToInt64(tokenInfo.Value<string>("expires"));
            DateTime TokenExpiration = EncodingHelper.DateTimeFromUnixTimestampMillis(expirationUnixTimestamp);

            return new Tuple<string, DateTime>(Token, TokenExpiration);
        }

        private string getToken2()
        {
            System.Text.ASCIIEncoding encoding = new System.Text.ASCIIEncoding();
            // string parameters = "username=APRIL&password=EGPcLv2K&client=requestip";
            string parameters = "username=webadmin&password=m4x$p1A&client=requestip";
            byte[] data = encoding.GetBytes(parameters);
            string tokenService = "https://maps.hatfieldgroup.com/maps/tokens/generateToken";
            System.Net.HttpWebRequest request = (System.Net.HttpWebRequest)System.Net.WebRequest.Create(tokenService);
            request.Method = "POST";
            request.ContentLength = data.Length;
            request.ContentType = "application/x-www-form-urlencoded";
            System.IO.Stream newStream = request.GetRequestStream();
            newStream.Write(data, 0, data.Length);
            //request.Credentials = new NetworkCredential(username, password);
            System.Net.WebResponse response = request.GetResponse();
            System.IO.Stream responseStream = response.GetResponseStream();
            System.IO.StreamReader readStream = new System.IO.StreamReader(responseStream);
            string token = readStream.ReadToEnd();
            return token;
        }
    }

}